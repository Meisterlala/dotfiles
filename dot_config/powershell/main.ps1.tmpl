# Disable update check
if ($env:POWERSHELL_UPDATECHECK -ne 'LTS')
{
    [System.Environment]::SetEnvironmentVariable('POWERSHELL_UPDATECHECK', 'LTS', 'User')
}

# Setup-PSReadline
# Show multi line history (Toggle with F2)
Set-PSReadLineOption -PredictionViewStyle ListView
# Show multi line autocomplete
Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete
# Match with already written command
# Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
# Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward

{{ if eq .chezmoi.os "linux" -}}
# Setup sudo
function sudo-last
{
    $history = Get-History -Count 3

    if ($history.Count -lt 1)
    {
                    Write-Host "No previous command found."
        return
    }

    $lastCommand = $history[-1].CommandLine

    if ([string]::IsNullOrWhiteSpace($lastCommand))
    {
        Write-Host "Last command was empty."
        return
    }

    Invoke-Expression "sudo $lastCommand"
}
Set-Alias -Name 's!' -Value sudo-last | Out-Null
Set-Alias -Name 's!!' -Value sudo-last | Out-Null
{{- end }}



# Install zoxide if not present
if (-not (Get-Command zoxide -ErrorAction SilentlyContinue))
{
    {{ if eq .chezmoi.os "windows" -}}
    Write-Host "Installing zoxide via winget…" -ForegroundColor Cyan
    winget install --silent ajeetdsouza.zoxide
    {{- else -}}
    Write-Host "Installing zoxide via curl…" -ForegroundColor Cyan
    bash -c "curl -sSfL https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | sh"
    {{- end }}
}

# Initialize zoxide
if (Get-Command zoxide -ErrorAction SilentlyContinue)
{
    Invoke-Expression (& { (zoxide init --cmd cd powershell | Out-String) })
}


{{ if .posh -}}
# Oh My Posh init
oh-my-posh init --config "$HOME/.config/oh-my-posh.yaml" pwsh | Invoke-Expression
{{- end }}


# EZA
if (Get-Command eza -ErrorAction SilentlyContinue)
{
    function Eza-With-Color
    {
        param (
            [Parameter(ValueFromRemainingArguments = $true)]
            [string[]]$Args
        )
        eza --icons=auto --color=always --color-scale=size -h @Args
    }
    Set-Alias -Name ls -Value Eza-With-Color | Out-Null
}


# Setup Chezmoi
if (Get-Command chezmoi -ErrorAction SilentlyContinue)
{
    Invoke-Expression (& { (chezmoi completion powershell | Out-String) })

    function Chezmoi-Edit-With-Args
    {
        param (
            [string]$FilePath
        )
        # List all if empty
        if ([string]::IsNullOrWhiteSpace($FilePath))
        {
            chezmoi managed -t
        } else
        {
            chezmoi edit --watch -a $FilePath
        }
    }
    Set-Alias -Name ce -Value Chezmoi-Edit-With-Args | Out-Null
}


# PS Completions
# Ensure PSCompletions is installed and loaded
if (-not (Get-Module -ListAvailable -Name PSCompletions))
{
    try
    {
        Install-Module PSCompletions -Scope CurrentUser -Force -ErrorAction Stop
        psc add 7z arch  basename  bun cargo chfs choco cksum conda date dd deno df dircolors dirname docker du env fold git hashsum head join kubectl link ln md5sum ngrok nl npm nproc oh-my-posh paste pip pnpm powershell psc pwsh python scoop scoop-install scoop-update sfsu uv volta winget wsh wsl wt yarn
    } catch
    {
        Write-Warning "Failed to install PSCompletions: $_"
    }
}

# Load the module if installed successfully
if (Get-Module -ListAvailable -Name PSCompletions)
{
    Import-Module PSCompletions -ErrorAction SilentlyContinue
    psc menu config enable_menu_enhance 0 *> $null
}



{{ if eq .chezmoi.os "linux" -}}
# Global cache
if (-not $global:PackageCache)
{
    $global:PackageCache = @{}
}

# Function to fetch and parse packages
function Get-PackageCompletions
{
    param (
        [string]$Command
    )

    if (-not $global:PackageCache.ContainsKey($Command))
    {
        $output = & $Command -Ss | Out-String

        $pattern = '^(?<repo>\S+)/(?<name>\S+)\s+(?<version>\S+)[^\n]*\n\s+(?<desc>[^\n]+)$'
        $matches = [regex]::Matches($output, $pattern, 'Multiline')

        $pkgs = foreach ($match in $matches)
        {
            [PSCustomObject]@{
                Repo        = $match.Groups['repo'].Value
                Name        = $match.Groups['name'].Value
                Version     = $match.Groups['version'].Value.Trim()
                Description = $match.Groups['desc'].Value.Trim()
            }
        }

        $global:PackageCache[$Command] = $pkgs
    }

    return $global:PackageCache[$Command]
}

# Register completions for pacman
Register-ArgumentCompleter -Native -CommandName 'pacman' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $packages = Get-PackageCompletions 'pacman'
    $prefix = [regex]::Escape($wordToComplete)

    $packages |
        Where-Object { $_.Name -match "^$prefix" } |
        Sort-Object -Property Name -Unique |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new(
                $_.Name,
                $_.Name,
                'ParameterValue',
                "$($_.Description) [$($_.Repo)/$($_.Version)]"
            )
        }
}

# Register completions for yay
Register-ArgumentCompleter -Native -CommandName 'yay' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $packages = Get-PackageCompletions 'yay'
    $prefix = [regex]::Escape($wordToComplete)

    $packages |
        Where-Object { $_.Name -match "^$prefix" } |
        Sort-Object -Property Name -Unique |
        ForEach-Object {
            [System.Management.Automation.CompletionResult]::new(
                $_.Name,
                $_.Name,
                'ParameterValue',
                "$($_.Description) [$($_.Repo)/$($_.Version)]"
            )
        }
}
{{- end }}

#
function Register-BashCompletion
{
    param(
        # The name of the command to register for completion
        [string]$Command
    )

    Register-ArgumentCompleter -Native -CommandName $Command -ScriptBlock {
        param(
            $wordToComplete,
            $commandAst,
            $cursorPosition
        )
        $cmd = $commandAst.GetCommandName()

        $helper = (Resolve-Path "~/.config/bash_complete.sh").Path
        $results = @(bash $helper  $cmd "$cmd $wordToComplete")

        foreach ($item in $results)
        {
            [System.Management.Automation.CompletionResult]::new($item, $item, 'ParameterValue', $item)
        }
    }
}

function Get-BashCompletions
{
    # Get commands that have registered completions
    $cmds = bash -c 'source /usr/share/bash-completion/bash_completion; complete -p' |
        ForEach-Object {
            if ($_ -match 'complete .* ([\w.-]+)$')
            {
                $matches[1]
            }
        }

    # Get filenames ignoring those starting with underscore
    $completionFiles = Get-ChildItem -Path '/usr/share/bash-completion/completions' -File |
        Where-Object { -not $_.Name.StartsWith('_') } |
        ForEach-Object { $_.Name }

    # Combine, filter out '-D', and get unique sorted list
    ($cmds + $completionFiles) |
        Where-Object { $_ -ne '-D' } |
        Sort-Object -Unique
}

function Import-BashCompletionsToPwsh
{
    $commands = Get-BashCompletions

    Write-Host "Registering $($commands.Count) commands for pwsh completion..." -ForegroundColor Green
    foreach ($cmd in $commands)
    {
        Register-BashCompletion $cmd
    }
}

{{ if eq .chezmoi.os "linux" -}}
if (Test-Path '/usr/share/bash-completion/bash_completion')
{
    Import-BashCompletionsToPwsh
}
{{- end }}}
